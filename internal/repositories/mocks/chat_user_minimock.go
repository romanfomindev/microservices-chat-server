package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/romanfomindev/microservices-chat-server/internal/repositories.ChatUser -o ./mocks/chat_user_minimock.go -n ChatUserMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/romanfomindev/microservices-chat-server/internal/models"
)

// ChatUserMock implements repositories.ChatUser
type ChatUserMock struct {
	t minimock.Tester

	funcCreateBatch          func(ctx context.Context, chatUsers models.ChatUser) (err error)
	inspectFuncCreateBatch   func(ctx context.Context, chatUsers models.ChatUser)
	afterCreateBatchCounter  uint64
	beforeCreateBatchCounter uint64
	CreateBatchMock          mChatUserMockCreateBatch

	funcFindUserInChat          func(ctx context.Context, chatId uint64, email string) (b1 bool)
	inspectFuncFindUserInChat   func(ctx context.Context, chatId uint64, email string)
	afterFindUserInChatCounter  uint64
	beforeFindUserInChatCounter uint64
	FindUserInChatMock          mChatUserMockFindUserInChat
}

// NewChatUserMock returns a mock for repositories.ChatUser
func NewChatUserMock(t minimock.Tester) *ChatUserMock {
	m := &ChatUserMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBatchMock = mChatUserMockCreateBatch{mock: m}
	m.CreateBatchMock.callArgs = []*ChatUserMockCreateBatchParams{}

	m.FindUserInChatMock = mChatUserMockFindUserInChat{mock: m}
	m.FindUserInChatMock.callArgs = []*ChatUserMockFindUserInChatParams{}

	return m
}

type mChatUserMockCreateBatch struct {
	mock               *ChatUserMock
	defaultExpectation *ChatUserMockCreateBatchExpectation
	expectations       []*ChatUserMockCreateBatchExpectation

	callArgs []*ChatUserMockCreateBatchParams
	mutex    sync.RWMutex
}

// ChatUserMockCreateBatchExpectation specifies expectation struct of the ChatUser.CreateBatch
type ChatUserMockCreateBatchExpectation struct {
	mock    *ChatUserMock
	params  *ChatUserMockCreateBatchParams
	results *ChatUserMockCreateBatchResults
	Counter uint64
}

// ChatUserMockCreateBatchParams contains parameters of the ChatUser.CreateBatch
type ChatUserMockCreateBatchParams struct {
	ctx       context.Context
	chatUsers models.ChatUser
}

// ChatUserMockCreateBatchResults contains results of the ChatUser.CreateBatch
type ChatUserMockCreateBatchResults struct {
	err error
}

// Expect sets up expected params for ChatUser.CreateBatch
func (mmCreateBatch *mChatUserMockCreateBatch) Expect(ctx context.Context, chatUsers models.ChatUser) *mChatUserMockCreateBatch {
	if mmCreateBatch.mock.funcCreateBatch != nil {
		mmCreateBatch.mock.t.Fatalf("ChatUserMock.CreateBatch mock is already set by Set")
	}

	if mmCreateBatch.defaultExpectation == nil {
		mmCreateBatch.defaultExpectation = &ChatUserMockCreateBatchExpectation{}
	}

	mmCreateBatch.defaultExpectation.params = &ChatUserMockCreateBatchParams{ctx, chatUsers}
	for _, e := range mmCreateBatch.expectations {
		if minimock.Equal(e.params, mmCreateBatch.defaultExpectation.params) {
			mmCreateBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBatch.defaultExpectation.params)
		}
	}

	return mmCreateBatch
}

// Inspect accepts an inspector function that has same arguments as the ChatUser.CreateBatch
func (mmCreateBatch *mChatUserMockCreateBatch) Inspect(f func(ctx context.Context, chatUsers models.ChatUser)) *mChatUserMockCreateBatch {
	if mmCreateBatch.mock.inspectFuncCreateBatch != nil {
		mmCreateBatch.mock.t.Fatalf("Inspect function is already set for ChatUserMock.CreateBatch")
	}

	mmCreateBatch.mock.inspectFuncCreateBatch = f

	return mmCreateBatch
}

// Return sets up results that will be returned by ChatUser.CreateBatch
func (mmCreateBatch *mChatUserMockCreateBatch) Return(err error) *ChatUserMock {
	if mmCreateBatch.mock.funcCreateBatch != nil {
		mmCreateBatch.mock.t.Fatalf("ChatUserMock.CreateBatch mock is already set by Set")
	}

	if mmCreateBatch.defaultExpectation == nil {
		mmCreateBatch.defaultExpectation = &ChatUserMockCreateBatchExpectation{mock: mmCreateBatch.mock}
	}
	mmCreateBatch.defaultExpectation.results = &ChatUserMockCreateBatchResults{err}
	return mmCreateBatch.mock
}

// Set uses given function f to mock the ChatUser.CreateBatch method
func (mmCreateBatch *mChatUserMockCreateBatch) Set(f func(ctx context.Context, chatUsers models.ChatUser) (err error)) *ChatUserMock {
	if mmCreateBatch.defaultExpectation != nil {
		mmCreateBatch.mock.t.Fatalf("Default expectation is already set for the ChatUser.CreateBatch method")
	}

	if len(mmCreateBatch.expectations) > 0 {
		mmCreateBatch.mock.t.Fatalf("Some expectations are already set for the ChatUser.CreateBatch method")
	}

	mmCreateBatch.mock.funcCreateBatch = f
	return mmCreateBatch.mock
}

// When sets expectation for the ChatUser.CreateBatch which will trigger the result defined by the following
// Then helper
func (mmCreateBatch *mChatUserMockCreateBatch) When(ctx context.Context, chatUsers models.ChatUser) *ChatUserMockCreateBatchExpectation {
	if mmCreateBatch.mock.funcCreateBatch != nil {
		mmCreateBatch.mock.t.Fatalf("ChatUserMock.CreateBatch mock is already set by Set")
	}

	expectation := &ChatUserMockCreateBatchExpectation{
		mock:   mmCreateBatch.mock,
		params: &ChatUserMockCreateBatchParams{ctx, chatUsers},
	}
	mmCreateBatch.expectations = append(mmCreateBatch.expectations, expectation)
	return expectation
}

// Then sets up ChatUser.CreateBatch return parameters for the expectation previously defined by the When method
func (e *ChatUserMockCreateBatchExpectation) Then(err error) *ChatUserMock {
	e.results = &ChatUserMockCreateBatchResults{err}
	return e.mock
}

// CreateBatch implements repositories.ChatUser
func (mmCreateBatch *ChatUserMock) CreateBatch(ctx context.Context, chatUsers models.ChatUser) (err error) {
	mm_atomic.AddUint64(&mmCreateBatch.beforeCreateBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBatch.afterCreateBatchCounter, 1)

	if mmCreateBatch.inspectFuncCreateBatch != nil {
		mmCreateBatch.inspectFuncCreateBatch(ctx, chatUsers)
	}

	mm_params := &ChatUserMockCreateBatchParams{ctx, chatUsers}

	// Record call args
	mmCreateBatch.CreateBatchMock.mutex.Lock()
	mmCreateBatch.CreateBatchMock.callArgs = append(mmCreateBatch.CreateBatchMock.callArgs, mm_params)
	mmCreateBatch.CreateBatchMock.mutex.Unlock()

	for _, e := range mmCreateBatch.CreateBatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateBatch.CreateBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBatch.CreateBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateBatch.CreateBatchMock.defaultExpectation.params
		mm_got := ChatUserMockCreateBatchParams{ctx, chatUsers}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateBatch.t.Errorf("ChatUserMock.CreateBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateBatch.CreateBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateBatch.t.Fatal("No results are set for the ChatUserMock.CreateBatch")
		}
		return (*mm_results).err
	}
	if mmCreateBatch.funcCreateBatch != nil {
		return mmCreateBatch.funcCreateBatch(ctx, chatUsers)
	}
	mmCreateBatch.t.Fatalf("Unexpected call to ChatUserMock.CreateBatch. %v %v", ctx, chatUsers)
	return
}

// CreateBatchAfterCounter returns a count of finished ChatUserMock.CreateBatch invocations
func (mmCreateBatch *ChatUserMock) CreateBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBatch.afterCreateBatchCounter)
}

// CreateBatchBeforeCounter returns a count of ChatUserMock.CreateBatch invocations
func (mmCreateBatch *ChatUserMock) CreateBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBatch.beforeCreateBatchCounter)
}

// Calls returns a list of arguments used in each call to ChatUserMock.CreateBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBatch *mChatUserMockCreateBatch) Calls() []*ChatUserMockCreateBatchParams {
	mmCreateBatch.mutex.RLock()

	argCopy := make([]*ChatUserMockCreateBatchParams, len(mmCreateBatch.callArgs))
	copy(argCopy, mmCreateBatch.callArgs)

	mmCreateBatch.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBatchDone returns true if the count of the CreateBatch invocations corresponds
// the number of defined expectations
func (m *ChatUserMock) MinimockCreateBatchDone() bool {
	for _, e := range m.CreateBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBatch != nil && mm_atomic.LoadUint64(&m.afterCreateBatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateBatchInspect logs each unmet expectation
func (m *ChatUserMock) MinimockCreateBatchInspect() {
	for _, e := range m.CreateBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatUserMock.CreateBatch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBatchCounter) < 1 {
		if m.CreateBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatUserMock.CreateBatch")
		} else {
			m.t.Errorf("Expected call to ChatUserMock.CreateBatch with params: %#v", *m.CreateBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBatch != nil && mm_atomic.LoadUint64(&m.afterCreateBatchCounter) < 1 {
		m.t.Error("Expected call to ChatUserMock.CreateBatch")
	}
}

type mChatUserMockFindUserInChat struct {
	mock               *ChatUserMock
	defaultExpectation *ChatUserMockFindUserInChatExpectation
	expectations       []*ChatUserMockFindUserInChatExpectation

	callArgs []*ChatUserMockFindUserInChatParams
	mutex    sync.RWMutex
}

// ChatUserMockFindUserInChatExpectation specifies expectation struct of the ChatUser.FindUserInChat
type ChatUserMockFindUserInChatExpectation struct {
	mock    *ChatUserMock
	params  *ChatUserMockFindUserInChatParams
	results *ChatUserMockFindUserInChatResults
	Counter uint64
}

// ChatUserMockFindUserInChatParams contains parameters of the ChatUser.FindUserInChat
type ChatUserMockFindUserInChatParams struct {
	ctx    context.Context
	chatId uint64
	email  string
}

// ChatUserMockFindUserInChatResults contains results of the ChatUser.FindUserInChat
type ChatUserMockFindUserInChatResults struct {
	b1 bool
}

// Expect sets up expected params for ChatUser.FindUserInChat
func (mmFindUserInChat *mChatUserMockFindUserInChat) Expect(ctx context.Context, chatId uint64, email string) *mChatUserMockFindUserInChat {
	if mmFindUserInChat.mock.funcFindUserInChat != nil {
		mmFindUserInChat.mock.t.Fatalf("ChatUserMock.FindUserInChat mock is already set by Set")
	}

	if mmFindUserInChat.defaultExpectation == nil {
		mmFindUserInChat.defaultExpectation = &ChatUserMockFindUserInChatExpectation{}
	}

	mmFindUserInChat.defaultExpectation.params = &ChatUserMockFindUserInChatParams{ctx, chatId, email}
	for _, e := range mmFindUserInChat.expectations {
		if minimock.Equal(e.params, mmFindUserInChat.defaultExpectation.params) {
			mmFindUserInChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindUserInChat.defaultExpectation.params)
		}
	}

	return mmFindUserInChat
}

// Inspect accepts an inspector function that has same arguments as the ChatUser.FindUserInChat
func (mmFindUserInChat *mChatUserMockFindUserInChat) Inspect(f func(ctx context.Context, chatId uint64, email string)) *mChatUserMockFindUserInChat {
	if mmFindUserInChat.mock.inspectFuncFindUserInChat != nil {
		mmFindUserInChat.mock.t.Fatalf("Inspect function is already set for ChatUserMock.FindUserInChat")
	}

	mmFindUserInChat.mock.inspectFuncFindUserInChat = f

	return mmFindUserInChat
}

// Return sets up results that will be returned by ChatUser.FindUserInChat
func (mmFindUserInChat *mChatUserMockFindUserInChat) Return(b1 bool) *ChatUserMock {
	if mmFindUserInChat.mock.funcFindUserInChat != nil {
		mmFindUserInChat.mock.t.Fatalf("ChatUserMock.FindUserInChat mock is already set by Set")
	}

	if mmFindUserInChat.defaultExpectation == nil {
		mmFindUserInChat.defaultExpectation = &ChatUserMockFindUserInChatExpectation{mock: mmFindUserInChat.mock}
	}
	mmFindUserInChat.defaultExpectation.results = &ChatUserMockFindUserInChatResults{b1}
	return mmFindUserInChat.mock
}

// Set uses given function f to mock the ChatUser.FindUserInChat method
func (mmFindUserInChat *mChatUserMockFindUserInChat) Set(f func(ctx context.Context, chatId uint64, email string) (b1 bool)) *ChatUserMock {
	if mmFindUserInChat.defaultExpectation != nil {
		mmFindUserInChat.mock.t.Fatalf("Default expectation is already set for the ChatUser.FindUserInChat method")
	}

	if len(mmFindUserInChat.expectations) > 0 {
		mmFindUserInChat.mock.t.Fatalf("Some expectations are already set for the ChatUser.FindUserInChat method")
	}

	mmFindUserInChat.mock.funcFindUserInChat = f
	return mmFindUserInChat.mock
}

// When sets expectation for the ChatUser.FindUserInChat which will trigger the result defined by the following
// Then helper
func (mmFindUserInChat *mChatUserMockFindUserInChat) When(ctx context.Context, chatId uint64, email string) *ChatUserMockFindUserInChatExpectation {
	if mmFindUserInChat.mock.funcFindUserInChat != nil {
		mmFindUserInChat.mock.t.Fatalf("ChatUserMock.FindUserInChat mock is already set by Set")
	}

	expectation := &ChatUserMockFindUserInChatExpectation{
		mock:   mmFindUserInChat.mock,
		params: &ChatUserMockFindUserInChatParams{ctx, chatId, email},
	}
	mmFindUserInChat.expectations = append(mmFindUserInChat.expectations, expectation)
	return expectation
}

// Then sets up ChatUser.FindUserInChat return parameters for the expectation previously defined by the When method
func (e *ChatUserMockFindUserInChatExpectation) Then(b1 bool) *ChatUserMock {
	e.results = &ChatUserMockFindUserInChatResults{b1}
	return e.mock
}

// FindUserInChat implements repositories.ChatUser
func (mmFindUserInChat *ChatUserMock) FindUserInChat(ctx context.Context, chatId uint64, email string) (b1 bool) {
	mm_atomic.AddUint64(&mmFindUserInChat.beforeFindUserInChatCounter, 1)
	defer mm_atomic.AddUint64(&mmFindUserInChat.afterFindUserInChatCounter, 1)

	if mmFindUserInChat.inspectFuncFindUserInChat != nil {
		mmFindUserInChat.inspectFuncFindUserInChat(ctx, chatId, email)
	}

	mm_params := &ChatUserMockFindUserInChatParams{ctx, chatId, email}

	// Record call args
	mmFindUserInChat.FindUserInChatMock.mutex.Lock()
	mmFindUserInChat.FindUserInChatMock.callArgs = append(mmFindUserInChat.FindUserInChatMock.callArgs, mm_params)
	mmFindUserInChat.FindUserInChatMock.mutex.Unlock()

	for _, e := range mmFindUserInChat.FindUserInChatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmFindUserInChat.FindUserInChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindUserInChat.FindUserInChatMock.defaultExpectation.Counter, 1)
		mm_want := mmFindUserInChat.FindUserInChatMock.defaultExpectation.params
		mm_got := ChatUserMockFindUserInChatParams{ctx, chatId, email}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindUserInChat.t.Errorf("ChatUserMock.FindUserInChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindUserInChat.FindUserInChatMock.defaultExpectation.results
		if mm_results == nil {
			mmFindUserInChat.t.Fatal("No results are set for the ChatUserMock.FindUserInChat")
		}
		return (*mm_results).b1
	}
	if mmFindUserInChat.funcFindUserInChat != nil {
		return mmFindUserInChat.funcFindUserInChat(ctx, chatId, email)
	}
	mmFindUserInChat.t.Fatalf("Unexpected call to ChatUserMock.FindUserInChat. %v %v %v", ctx, chatId, email)
	return
}

// FindUserInChatAfterCounter returns a count of finished ChatUserMock.FindUserInChat invocations
func (mmFindUserInChat *ChatUserMock) FindUserInChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindUserInChat.afterFindUserInChatCounter)
}

// FindUserInChatBeforeCounter returns a count of ChatUserMock.FindUserInChat invocations
func (mmFindUserInChat *ChatUserMock) FindUserInChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindUserInChat.beforeFindUserInChatCounter)
}

// Calls returns a list of arguments used in each call to ChatUserMock.FindUserInChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindUserInChat *mChatUserMockFindUserInChat) Calls() []*ChatUserMockFindUserInChatParams {
	mmFindUserInChat.mutex.RLock()

	argCopy := make([]*ChatUserMockFindUserInChatParams, len(mmFindUserInChat.callArgs))
	copy(argCopy, mmFindUserInChat.callArgs)

	mmFindUserInChat.mutex.RUnlock()

	return argCopy
}

// MinimockFindUserInChatDone returns true if the count of the FindUserInChat invocations corresponds
// the number of defined expectations
func (m *ChatUserMock) MinimockFindUserInChatDone() bool {
	for _, e := range m.FindUserInChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindUserInChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindUserInChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindUserInChat != nil && mm_atomic.LoadUint64(&m.afterFindUserInChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindUserInChatInspect logs each unmet expectation
func (m *ChatUserMock) MinimockFindUserInChatInspect() {
	for _, e := range m.FindUserInChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatUserMock.FindUserInChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindUserInChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindUserInChatCounter) < 1 {
		if m.FindUserInChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatUserMock.FindUserInChat")
		} else {
			m.t.Errorf("Expected call to ChatUserMock.FindUserInChat with params: %#v", *m.FindUserInChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindUserInChat != nil && mm_atomic.LoadUint64(&m.afterFindUserInChatCounter) < 1 {
		m.t.Error("Expected call to ChatUserMock.FindUserInChat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatUserMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateBatchInspect()

		m.MinimockFindUserInChatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatUserMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatUserMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBatchDone() &&
		m.MinimockFindUserInChatDone()
}
